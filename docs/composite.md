# <i class="fas fa-puzzle-piece" style="color:#FA023C"></i> Composite Pattern
Expressions to filter the articles generated by a `Processor` (known as filter
expressions) can be difficult to represent in code. Filter expressions are
composed of keywords and binary operators. The keywords are strings that, if
found in an article, indicate that the article should be passed onto the client.
The operators in use are `&&` and `||` which represent "logical and" and
"logical or" respectively.

For example, a filter expression might look like:
```
Harris & ( washingtonpost | usatoday )
```
An article passes this filter if it includes the keyword "Harris" and either the
keyword "washingtonpost" or the keyword "usatoday". Note how the parentheses
indicate precedence.

To optimize performance and readability, filter expressions should be
represented in a way such that relevant data can be accessed without needing to
do any string parsing. The Composite Pattern is well suited for this
application.

## Pattern Used & SOLID Principle Addressed
The Composite Pattern is useful to obscure the difference between a composition
of objects in a tree-like structure and an individual object. This makes it easy
for the client to use both entities in the same manner. Leaf nodes of the tree
will often represent the most basic individual object. Interior nodes will
represent 'sub-compositions', or sub-trees of a composition of objects that can
be used just like the whole tree.

One pattern addressed by the Composite Pattern is the dependency inversion
principle. This principle asserts that client code should depend upon
abstractions, not concretions. Regardless of how complex a composition may be,
or how many different types of nodes it may contain, the client should be able
to use the composition in a simple, abstract way defined by an interface.

## Implementation of Design
In the spirit of abstraction, the client is only exposed to a single
`evaluate()` method on the `FilterExpression`. `evaluate()` accepts an article,
and returns whether or not it passes the filter and will be returned by the
`Processor`.
```java
public interface FilterExpression {
  public boolean evaluate(Article a);
}
```

There are two classes that take part in the composition itself, `FilterKeyword`
and `FilterSelector`. Each of these implement `FilterExpression`, meaning that
either can be used where a `FilterExpression` is expected, satisfying the Liskov
subsitution principle.

`FilterKeyword` serves as the "leaf node" in the composition tree, and
represents a single keyword, like "Harris". The `evaluate()` method of
`FilterKeyword` checks if the keyword exists in any of the relevant fields of
the article. The details of `containsKeyword()` are omitted for clarity; it is
essentially a substring matching method.
```java
public FilterKeyword(String keyword) {
  this.keyword = keyword;
}

public boolean evaluate(Article a) {
  return containsKeyword(a.getDescription())
      || containsKeyword(a.getTitle())
      || containsKeyword(a.getPublishedAt())
      || containsKeyword(a.getUrl());
}
```

`FilterSelector` serves as an "interior node" in the composition tree, and
represents several keywords connected by the binary operators `&&` and `||`.
This implementation makes use of the native `BinaryOperator` class in Java,
which we have implemented for an `AndOperator` and an `OrOperator`. If we wanted
to add more operators in the future, we could through this interface. The
`evaluate()` method applies the logical operator to the results of the
`evaluate()` method of the left and right filter sub-expressions. In this way,
one can see how the tree structure is composed, much like evaluating an abstract
syntax tree.
```java
public FilterSelector(FilterExpression left, FilterExpression right,
                      BinaryOperator<Boolean> binaryOperator) {
  this.left = left;
  this.right = right;
  this.binaryOperator = binaryOperator;
}

public boolean evaluate(Article a) {
  return binaryOperator.apply(left.evaluate(a), right.evaluate(a));
}
```

## Benefits of This Design in Context
One major benefit of using the Composite Pattern to represent filter expressions
is simplicity of use for the client. The client is blind to the details of the
implementation of the filter expression evaluation and only needs to pass an
article to be evaluated. This satisfies the dependency inversion principle
mentioned earlier.

Another benefit is the small footprint of this pattern. We only need two
relatively small classes, `FilterKeyword` and `FilterSelector`, to represent
even the most complex filter expressions. The tree structure of this pattern
handles all of the organization and nesting for us.

It is also a relatively performant approach, as we don't need to do any string
parsing and each keyword is only evaluated once for a single article. There is
also minimal conditional logic because the operators and the expressions exist
behind common interfaces.

## Comparison Against Alternative Designs
A naive approach to the problem of evaluating filter expressions might take the
filter expression string directly from the config file and evaluate it through
complex parsing and conditional logic for a given article. We'll call this class
`NaiveEvaluator`. Evaluation would include splitting the string on whitespace
and using regular expressions to determine if each token is a keyword, operator,
or parenthesis. Keywords could be checked against the fields of the article and
the results could be combined based on the operators. Determining which
subexpressions have precedence with respect to the parentheses, however, would
be very complicated.

Obviously, the `NaiveEvaluator` is a strawman design, whose only real advantage
is a slightly simpler architecture. We only need one class with the naive
approach, whereas we need to compose 2 classes that share an interface into a
tree with the Composite Pattern.

However, the `NaiveEvaluator` is likely far more complicated, less readable, and
less performant in its implementation due to copious string parsing and repeated
conditional logic. It would also be very difficult to add a new operator, or
otherwise change the format of the filter expression in the naive approach.
Admittedly, it very well could be difficult to extend the filter expression
format in the Composite Pattern approach as well, which is a limitation of the
pattern.

It's hard to imagine an "unreasonable composition" for a filter expression, but
if such a thing did exist, one could imagine that you might have more control
over the syntax of the filter expression using a `NaiveEvaluator` due the string
parsing it performs. The Composite Pattern can be poor at restricting
unreasonable compositions.
