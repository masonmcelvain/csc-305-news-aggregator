# <i class="fas fa-globe-americas" style="color:#FA023C"></i> Visitor Pattern

To allow for configuration, the News Aggregator program accepts a configuration
file that must follow a specific format. The config file is parsed by an ANTLR
module that produces a parse tree containing the data found in the config file.
The problem that this instance of the visitor pattern seeks to address is how to
collect the relevant data, and only the relevant data, from the parse tree for
use by the News Aggregator program.

## Pattern Used & SOLID Principle Addressed
The Visitor Pattern is a way in which to add functionality to a target class (or
set of target classes) without modifying the existing classes or extending those
classes. When a visitor visits a target object, it performs some operation using
the instance provided. This addresses the [single-responsibility
principle](https://en.wikipedia.org/wiki/Single-responsibility_principle) in
that the target classes can remain the same (i.e. there is no need to add
methods to the target class that are unrelated to the primary responsibility of
the target class).

There is one (albeit minor) modification necessary to the target classes - they
must expose an `accept` method that accepts a visitor (preferably, all visitors
will implement the same interface so there only needs to be a single `accept`
method). The `accept` method performs a 'double dispatch' by simply calling the
provided visitor with `this`.
```java
public <T> T accept(Visitor<T> visitor) {
  return visitor.visit(this);
}
```

## Implementation of Design
The News Aggregator uses a visitor to generate article processors given the
ANTLR parse tree of a config file to visit, known by ANTLR as a 'Source
Context'. So, when the client accepts a `AggregatorAllProcessorsVisitor` (yikes,
naming is hard) on a parse tree, they will get back a list of processors, one
for each data source listed in the config file.
```java
List<Processor> processors = parseTree.accept(aggregatorAllProcessorsVisitor);
```

But how does the visitor *do* that? Well, the ANTLR parse tree ('Source
Context') invokes `visitSources` on `this`, and executes `visitSources` defined
in the `AggregatorAllProcessorsVisitor`.
```java
public List<Processor> visitSources(AggregatorConfigParser.SourcesContext ctx) {
  AggregatorSingleProcessorVisitor processorVisitor = new AggregatorSingleProcessorVisitor();
  List<Processor> processors = new ArrayList<>();

  for (AggregatorConfigParser.SourceTypeContext sourceType : ctx.sourceType()) {
    ArticleProcessor processor = sourceType.accept(processorVisitor);
    processors.add(processor);
  }

  return processors;
}
```

That builds a list of individual processors, each generated by ANOTHER visitor
whose responsibility is to produce a `Processor` given a `sourceType` parse
tree. The parse tree will call the appropriate `visit` method on
`AggregatorSingleProcessorVisitor` based on the type of data source it
represents. A parse tree for a file source will call the following
`visitFileSourceType` method.
```java
public Processor visitFileSourceType(AggregatorConfigParser.FileSourceTypeContext ctx) {
  private static final AggregatorFormatVisitor formatVisitor = new AggregatorFormatVisitor();
  private static final AggregatorDataSourceVisitor locationVisitor =
      new AggregatorDataSourceVisitor();
  ArticleJsonParser parser = ctx.accept(formatVisitor);
  DataSource source = ctx.accept(locationVisitor);
  return new Processor(parser, source);
}
```

More visitors will in turn generate the `Parser` and `DataSource` necessary to
build the `Processor`. This happens to be the last 'layer' of visitors. The
`AggregatorFormatVisitor` will return a `NewsApiParser` or `SimpleParser`
depending on the 'Format' specified in the parse tree for the given file/url
source. The `AggregatorDataSourceVisitor` will return a `DataSource` wrapper
around the actual source of the JSON data to be used by the Parser (e.g. data
from a file or a network connection).

## Benefits of This Design in Context
*Clearly articulate the benefits of the Design Pattern or SOLID principle for this design instance in the context of your code.*

## Comparison Against Alternative Designs
*Discuss alternative design options and compare the advantages/disadvantages with your design. This may include a comparison to a traditional technique, to a naive approach, to an approach you initially used, or to an approach that, on reflection, you wish you had used.*
